%\VignetteIndexEntry{A step-by-step guide to using linkcomm}
%\VignetteDepends{grid, igraph, RColorBrewer}
%\VignetteKeyword{linkcomm}
%\VignettePackage{linkcomm}

\documentclass[a4paper, oneside, 10pt]{article}

\usepackage[pdftex]{graphicx}
\usepackage{calc}
\usepackage{sectsty}
\usepackage{caption}
\usepackage{natbib}
\renewcommand{\captionfont}{\it\sffamily}
\renewcommand{\captionlabelfont}{\bf\sffamily}
\allsectionsfont{\sffamily}

\usepackage[a4paper, left=25mm, right=20mm, top=20mm, bottom=25mm, nohead]{geometry}
\setlength{\parskip}{1.5ex}
\setlength{\parindent}{0cm}
\pagestyle{empty}

\usepackage{Sweave}


\title{The generation, visualization, and analysis of link communities in arbitrary networks with the R package \textbf{linkcomm}}
\author{Alex T. Kalinka}
\date{\today \\
	alex.t.kalinka@gmail.com \\
	Max Planck Institute of Molecular Cell Biology and Genetics, Dresden, Germany.}

\begin{document}
\maketitle

\begin{abstract}

\noindent Identifying communities of related nodes in networks is an essential tool enabling researchers to make sense of complex data sets. The {\tt linkcomm} package greatly facilitates this process by extracting communities of links from networks of arbitrary size and type. By clustering links, as opposed to nodes, it is possible for nodes to belong to multiple communities thereby revealing the overlapping and nested structure of the network and uncovering the key nodes that form connections across several communities. In addition to this, {\tt linkcomm} provides extensive functionality for visualizing and analysing the resulting link communities.


\end{abstract}


\section{Introduction}

The representation of systems of interacting elements as networks has brought fresh perspectives and insights to the analysis of complex phenomena from the biological to the social sciences. When analysing the structure, function, and dynamics of these networks it is extremely useful to identify sets of related nodes, known as communities \citep{radicchietal2004}.

This approach is greatly enhanced by clustering the links between nodes, rather than the nodes themselves \citep{evans&lambiotte2009, ahnetal2010}. With this method it is possible for nodes to belong to multiple communities, and this in turn reveals the overlapping and nested structure of the network while simultaneously identifying key nodes with membership across several communities.

The R package {\tt linkcomm} \citep{kalinka&tomancak2011} implements the algorithm proposed by \cite{ahnetal2010}. Similarities between links that share a node are assigned using the Jaccard coefficient and these similarities are then used to hierarchically cluster the links. The resulting dendrogram is cut at a point that maximises the density of links within the clusters after normalizing against the maximum and minimum numbers of links possible in each cluster.

\section{Quick start}

To install {\tt linkcomm} run the following command within R:

<<eval = FALSE>>=
install.packages("linkcomm")
@

\noindent To run an interactive demonstration of linkcomm within R:

<<eval = FALSE>>=
demo(topic = "linkcomm", package = "linkcomm")
@


\clearpage


\section{Example session}

To illustrate the package we will extract communities from a densely-connected sub-network from the yeast protein interactome \citep{yuetal2008}. This sub-network includes 56 proteins and 449 interactions involved in transcription (see \cite{ahnetal2010}, SI, p. 16). The network is undirected and unweighted (see section \ref{sec:dirweight} for dealing with directed and weighted networks).

\subsection{Extracting link communities}

When extracting communities from a network, the input data must be arranged as a simple edge list.

<<results = hide, echo = FALSE>>=
library(linkcomm)
@

<<eval = FALSE>>=
yeast_pp <- read.table("pp_rnapol.txt", header = FALSE)
head(yeast_pp)
@

<<echo = FALSE>>=
load(file = "networks.rda")
head(pp_rnapol)
@

\noindent In the above edge list, each row corresponds to an interaction between the elements in each of the columns. The interacting elements can be character names, as above, or integer numbers.

<<eval = FALSE>>=
lc <- getLinkCommunities(yeast_pp)
@

<<echo = FALSE>>=
cat("   Removing loops...\n   Removing edge duplicates...\n   Calculating edge similarities for 449 edges... 100.00%\n   Hierarchical clustering of edges...\n   Calculating link densities... 100.00%\n   Partition density maximum height =  0.3333333\n   Finishing up...4/4... 100%\n   Plotting...\n   Colouring dendrogram... 100%\n")
@


\begin{figure}[!ht]%figure1
\centerline{\includegraphics[width=5in]{fig1_vignette.pdf}}
\caption{Example output from extracting link communities from a yeast protein interaction network involved in transcription.}\label{exampleoutput}
\end{figure}


\noindent The algorithm returns an object of class {\tt linkcomm} and plots a summary of the results (Fig. \ref{exampleoutput}). Included in this object are the communities that were extracted together with additional data required for plotting and further analysing the communities. \\ 

\noindent To view a summary of this object:

<<results = hide, echo = FALSE>>=
lc <- getLinkCommunities(pp_rnapol, hcmethod = "single")
@

<<>>=
print(lc)
@ 



%\setkeys{Gin}{width=2\linewidth}
\begin{figure}[!ht]
\advance\leftskip -3cm
\centerline{\includegraphics[width=6.5in]{graph_layout_examples.pdf}}
%<<fig = TRUE, echo = FALSE>>=
%par(mfcol=c(2,1),mar=rep(0,4),pty="m",mgp=rep(0,3),xpd=NA)
%plot(lc, type = "graph", layout = "spencer.circle", verbose = FALSE, shownodesin = 3, jitter = 0.5, margin = -0.1)
%plot(lc, type = "graph", layout = layout.fruchterman.reingold, shownodesin = 3, margin = -0.2)
%@
\caption{Visualization of link communities using graphs. The panel on the left shows a Spencer circle layout \citep{spencer2010}, while the panel on the right shows a Fruchterman-Reingold layout. In both graphs, we show only the nodes that belong to 3 or more communities. Numbers around the circumference of the circle refer to community IDs.}\label{graphs}
\end{figure}


\subsection{Visualizing link communities}

We can visualize link communities using coloured edges in a graph layout. 

<<eval = FALSE>>=
plot(lc, type = "graph", layout = layout.fruchterman.reingold)
plot(lc, type = "graph", layout = "spencer.circle")
@

\noindent To aid the visualization of key nodes we can limit the display of nodes using the {\tt shownodesin} parameter. The following displays only the nodes that belong to 3 or more communities (Fig. \ref{graphs}):

<<eval = FALSE>>=
plot(lc, type = "graph", layout = "spencer.circle", shownodesin = 3)
@

\noindent We can also visualize node community membership for the top-connected nodes using a community membership matrix (Fig. \ref{members}):

<<eval = FALSE>>=
plot(lc, type = "members")
@

\noindent We can also display a summary of the results of the link communities algorithm (Fig. \ref{exampleoutput}):

<<eval = FALSE>>=
plot(lc, type = "summary")
@

\noindent Additionally, we can simply plot the dendrogram on its own with coloured community clusters:

<<eval = FALSE>>=
plot(lc, type = "dend")
@


\setkeys{Gin}{width=0.6\linewidth}
\begin{figure}[!ht]
 \centering
\advance\leftskip -1.5cm
<<fig = TRUE, echo = FALSE>>=
plot(lc, type = "members", nodes = head(names(lc$numclusters),10))
@
\caption{Visualizing community membership for nodes that belong to the most communities. Colours indicate community-specific membership.}\label{members}
\end{figure}


\subsection{Analysing link communities}

\subsubsection{Nested communities}

Nodes can belong to multiple link communities, and so it is possible to discover sets of nodes that belong to a community that is entirely nested within a larger community of nodes:

<<results = hide, echo = FALSE>>=
nc <- getAllNestedComm(lc)
@

<<eval = FALSE>>=
getAllNestedComm(lc)
@

<<echo = FALSE>>=
nc
@

\noindent This result indicates that there is one nested community; the nodes in community 9 are entirely nested within the nodes of community 11. We can verify this by plotting these communities as a graph (Fig. \ref{nested}):

<<eval = FALSE>>=
getNestedHierarchies(lc, clusid = 9)
@

\noindent or

<<eval = FALSE>>=
plot(lc, type = "graph", clusterids = c(9,11))
@

\setkeys{Gin}{width=0.6\linewidth}
\begin{figure}[!ht]
 \centering
\advance\leftskip -2.5cm
<<fig = TRUE, echo = FALSE>>=
plot(lc, type = "graph", clusterids = c(9,11), frame = TRUE)
@
\caption{Nested community structure revealed by {\tt linkcomm}. YML098W, YCR042C, and YML114C belong to both communities.}\label{nested}
\end{figure}


\subsubsection{Relationships between communities}

We can also explore the relationships between communities based on the numbers of shared nodes. To do this we can hierarchically cluster the communities after scoring the pair-wise similarities between them using the Jaccard coefficient (based on the number of nodes that they share).

<<echo = FALSE, results = hide>>=
cr <- getClusterRelatedness(lc, hcmethod = "ward")
@

<<eval = FALSE>>=
cr <- getClusterRelatedness(lc, hcmethod = "ward")
@


%\setkeys{Gin}{width=0.8\linewidth}
\begin{figure}[!ht]
\advance\leftskip -2.75cm
%<<fig = TRUE, echo = FALSE, results = hide>>=
%par(mfcol=c(1,2),mar=rep(0,4),pty="m",mgp=rep(0,3),xpd=NA)
%getClusterRelatedness(lc)
%cutDendrogramAt(cr, cutat = 1.2)
%@
\centerline{\includegraphics[width=6.8in]{cluster_relatedness.pdf}}
\caption{Dendrograms showing, on the left, the similarity between link communities, and, on the right, clustering between these communities to produce 3 meta-communities.}\label{clusterrelatedness}
\end{figure}


\noindent This function returns a hierarchical clustering object of class ``hclust'' and plots the dendrogram (Fig. \ref{clusterrelatedness}). After inspecting this dendrogram, we can select a height at which to cut the dendrogram and extract the resulting meta-communities.

<<eval = FALSE, results = hide>>=
cutDendrogramAt(cr, cutat = 1.2)
@

<<echo = FALSE, results = hide>>=
tt <- cutDendrogramAt(cr, cutat = 1.2)
@

<<echo = FALSE>>=
print(tt)
@

\noindent This returns the meta-communities (clusters of community IDs). Alternatively, we could have cut the dendrogram using the {\tt cutat} option in the original clustering function, {\tt getClusterRelatedness}. We can verify that these meta-communities make sense by inspecting the communities in the Spencer circle (Fig. \ref{graphs}). Note that nodes may still belong to multiple meta-communities.

\subsubsection{Community centrality}

In link communities, nodes may belong to several communities, and so it is possible to measure the importance of a node in a network based on the number of communities to which it belongs. To do this, we weight the membership of a node in a community by how distinct that community is from the other communities to which the same node belongs

\begin{equation}
C_{c}(i)=\sum_{i\in j}^{N}\left(1-\frac{1}{m}\sum_{i\in j\cap k}^{m}S(j,k)\right),
\end{equation}

\noindent where the main sum is over the $N$ communities to which node $i$ belongs, and $S(j,k)$ refers to the similarity between community $j$ and $k$, calculated as the Jaccard coefficient for the number of shared nodes between each community pair, and this is averaged over the $m$ communities paired with community $j$ and in which node $i$ jointly belongs.

Nodes that belong to a lot of different communities will get the largest community centrality scores, whereas nodes that belong to overlapping, nested or few communities will get the lowest scores.\\

\noindent We can calculate this value for a set of nodes that have been assigned to link communities:

<<echo = FALSE, results = hide>>=
cc <- getCommunityCentrality(lc)
@

<<eval = FALSE>>=
cc <- getCommunityCentrality(lc)
@

<<>>=
head(sort(cc, decreasing = TRUE))
@


\noindent Comparing against the unweighted community membership, we find differences:

<<>>=
head(lc$numclusters)
@

\subsubsection{Community modularity and connectedness}

We can also calculate the modularity of communities - the relative number of links within the community versus links outside of the community - and its inverse, community connectedness. The modularity of community $i$ can be written as

\begin{equation}
M_{i}=\left(\frac{e_{w}(i)}{n_{i}(n_{i}-1)/2}\right).\left(\frac{e_{b}(i)}{n_{i}\bar{d}}\right)^{-1},
\end{equation}

\noindent where $e_{w}(i)$ and $e_{b}(i)$ are the number of links within and without community $i$ respectively, $n_{i}$ is the number of nodes in community $i$, and $\bar{d}$ is the average degree of nodes in the network.\\

\noindent We can calculate and plot the modularity of the communities in our network (Fig. \ref{modularity}):

<<eval = FALSE>>=
cm <- getCommunityConnectedness(lc, conn = "modularity")
plot(lc, type = "commsumm", summary = "modularity")
@

\setkeys{Gin}{width=0.6\linewidth}
\begin{figure}[!ht]
 \centering
%\advance\leftskip -2.5cm
<<fig = TRUE, echo = FALSE>>=
plot(lc, type = "commsumm", summary = "modularity", verbose = FALSE)
@
\caption{The modularity of different link communities.}\label{modularity}
\end{figure}

\noindent We can verify that these measures make sense by inspecting the communities in the Spencer circle (Fig. \ref{graphs}).

\subsubsection{User-defined link communities}

It is also possible for the user to extract link communities that are not defined by the maximisation of the link partition density. Instead, the user can inspect the clustering dendrogram and select a different height at which to extract communities:

<<echo = FALSE, results = hide>>=
lc2 <- newLinkCommsAt(lc, cutat = 0.4)
@

<<eval = FALSE>>=
lc2 <- newLinkCommsAt(lc, cutat = 0.4)
@

\noindent Now the number and composition of the communities has changed, but we use the clustering method from the original clustering:

<<>>=
print(lc2)
@


\subsubsection{Community membership of nodes}

We can extract the nodes from single or multiple communities:

<<>>=
getNodesIn(lc, clusterids = c(4,5))
@



\subsection{Directed and weighted networks}
\label{sec:dirweight}

When analysing directed networks, we need to specify that the network is directed, and/or choose a weight for links that share nodes yet are in the opposite orientation (the default value is 0.5):

<<eval = FALSE>>=
lc <- getLinkCommunities(yeast_pp, directed = TRUE, dirweight = 0.8)
@

\noindent For weighted networks, the input data must be an edge list with an additional third column of numerical weights, for example:

<<>>=
head(weighted)
@

\noindent For both directed and weighted networks, the algorithm will score the similarities between links that share a node using the Tanimoto coefficient:

\begin{equation}
S(e_{ik},e_{jk})=\frac{\mathbf{a}_{i}.\mathbf{a}_{j}}{|\mathbf{a}_{i}|^{2}+|\mathbf{a}_{j}|^{2}-\mathbf{a}_{i}.\mathbf{a}_{j}},
\end{equation}

\noindent where $\mathbf{a}_{i}$ refers to a vector describing the weights of links between node $i$ and the nodes in the first-order neighbourhoods of both nodes $i$ and $j$ (equal to $0$ in the event of an absent link). For directed networks, links to nodes shared by both node $i$ and $j$ are given a user-defined weight below $1$ if they are in the opposite orientation. 


\subsection{Handling large networks}

The {\tt linkcomm} package can handle networks of any size. To do so, the upper triangular dissimilarity matrix used by the hierarchical clustering algorithm is compressed and written to disk as a temporary file. This matrix is then read, modified, and re-written (by a compiled C{}\verb!++! function) as clustering proceeds until the file size is 0 bytes. The speed at which large networks are processed will depend on the power of the computer being used. The size of the file that holds the compressed matrix may also be very large, so hard disk space could be a limiting factor for extremely large networks.

We make no assumptions about the computer resources available to end users, and so we provide a parameter, {\tt edglim}, which can be modified by the user and which determines the maximum permissible size of the input network in terms of links for it to be handled in memory - above this size the dissimilarity matrix will be handled on the disk. The default value is $10^{4}$ links, but this can be modified:

<<eval = FALSE>>=
lc <- getLinkCommunities(yeast_pp, edglim = 10)
@

As a guide, a network with $10^{4}$ links will require $((10^{4})^{2})*8 = 800$ MB to be handled in an uncompressed format in the memory.


\subsection{Exporting link communities to Cytoscape}

Cytoscape is an open source platform for complex-network analysis and visualization \footnote{http://www.cytoscape.org/}. We can export our link communities into an edge attribute file that can be imported into Cytoscape:

<<eval = FALSE>>=
linkcomm2cytoscape(lc, interaction = "pp", ea = "linkcomms.ea")
@

This will save an edge attribute file to ``linkcomms.ea'' in the current directory.



\begin{thebibliography}{}

\bibitem[Ahn {\it et al}., 2010]{ahnetal2010} Ahn, Y.Y., Bagrow, J.P., and Lehmann, S. (2010) Link communities reveal multiscale complexity in networks. {\it Nature}, {\bf 466}, 761-764.

%\bibitem[Cline {\it et al}., 2007]{clineetal2007} Cline,M.S., \emph{et al}. (2007) Integration of biological networks and gene expression data using Cytoscape. {\it Nat Protoc}, {\bf 2}, 2366-2382.

\bibitem[Evans and Lambiotte, 2009]{evans&lambiotte2009} Evans, T.S., and Lambiotte, R. (2009) Line graphs, link partitions and overlapping communities. {\it Phys. Rev. E.}, {\bf 80}, 016105.

\bibitem[Kalinka and Tomancak, 2011]{kalinka&tomancak2011} Kalinka, A.T., and Tomancak, P. (2011) linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. {\it Bioinformatics}, doi: 10.1093/bioinformatics/btr311.

\bibitem[Radicchi {\it et al}., 2004]{radicchietal2004} Raddichi, F., \emph{et al}. (2004) Defining and identifying communities in networks. {\it Proc. Natl Acad. Sci USA}, {\bf 101}, 2658-2663.

\bibitem[Spencer, 2010]{spencer2010} Spencer, R., (2010). http://scaledinnovation.com/analytics/communities/comlinks.html.

\bibitem[Yu {\it et al}., 2008]{yuetal2008} Yu, H., \emph{et al}. (2008) High-quality binary protein interaction map of the yeast interactome network. {\it Science}, {\bf 322}, 104-110.



\end{thebibliography}


\end{document}
